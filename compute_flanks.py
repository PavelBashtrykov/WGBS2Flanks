#!/usr/bin/env python3.10

################################################################################
# This script is written by Pavel Bashtrykov
# pavel.bashtrykov@ibtb.uni-stuttgart.de
# pavel.bashtrykov@gmail.com
################################################################################

import argparse
from itertools import product
from collections import OrderedDict


def main():
    # paramethers of the run
    parser = argparse.ArgumentParser()
    parser.add_argument("--infile", help="Input file", type=str, required=True)
    parser.add_argument("--outfile", help="Output file", type=str)
    parser.add_argument(
        "--depth",
        help="Define a minimum depth of covarage for cytosines to be included into the analysis",
        required=False,
    )
    parser.add_argument("--motif", help="Sequence motif, default: CG", type=str, required=False)
    parser.add_argument("--level", help="File contains methylation level and no sequencing depth information", action="store_true")
    parser.add_argument("--distribution", help="Computes the number of observations of each flank in a sample/genome", action="store_true")
    args = parser.parse_args()

    infile = args.infile
    savein = (
        args.outfile if args.outfile else "flanks_methylation.csv"
    )  # default name for outfile
    seq_depth = (
        int(args.depth) if args.depth else 10
    )  # default value of sequencing depth

    seq_motif = args.motif if args.motif else "CG"


    # main part
    print("Flanking sequence analysis is running...")
    for flank_size in range(1, 4):
        empty_flanks_dict = _make_flanks_dict(flank_size, motif=seq_motif)
        if args.distribution:
            flanks_stat = _compute_flanks_distribution(infile, flank_size, empty_flanks_dict, motif=seq_motif)
        elif args.level:
            flanks_stat = _compute_flanks_methylation_level(infile, flank_size, empty_flanks_dict, motif=seq_motif)
        else:
            flanks_stat = _compute_flanks_methylation(infile, flank_size, empty_flanks_dict, seq_depth, motif=seq_motif)
        
        _save_data(flanks_stat, savein)
        print(f"Flank {flank_size} is done")

def _make_flanks_dict(flank_size: int, motif: str = "CG") -> OrderedDict[str, list]:
    """
    Makes an empty dictionary of flanks

    Parameters
    ----------
    flank_size : int, number of nucleotides flanking CG to analyse (max 3).
        E.g. if flank_size=1 then flank is NCGN
    
    motif : str, central motif.
        E.g. CG, CA, etc., default = "CG"

    Returns
    -------
    flank_dict : dictionary, all flanks with [0,0] [the first position stores a number of occurrences of this flank,
        the second - a sum of methylation levels]
        {"ACGA": [0,0],
        "ACGT": [0,0],
        ..............,
        "CCGC": [0,0]
        }
        
    """

    letters = "ACGT" # nucleotides
    flanks_list = ["".join(x) for x in list(product(letters, repeat=flank_size * 2))]
    flanks_dict = OrderedDict()
    for f in flanks_list:
        sequence = f[:flank_size] + motif + f[flank_size:]
        flanks_dict[sequence] = [0, 0]
    return flanks_dict

def _compute_flanks_methylation(
    infile: str, flank_size: int, flank_dict: OrderedDict, depth_limit: int = 10, motif: str = "CG"
):
    """Computes methylation of flanks
    !!! In the current implementation uses 22 nt sequences as inputs!!!
    
    Parameters
    ----------

    infile : str, input file with sequences and methylation data
        examplary line: 1;13;CG;CG::chr1:3010402-3010424(+) ctggactgggcgaagtgggtgt
    
    flank_size : int, number of nucleotides flanking central motif to analyse (max 3)
    flank_dict : dict, a disctionary of flanks to store statistics,
        generated by _make_flanks_dict

    depth_limit : int, sets a threshold for sequencing depth, default = 10,
        a minimum number of sequencing depth to take cytosine into the analysis
    
    motif : str, a central motif.
        E.g. CG, CA, etc., default = "CG"
    
    Returns
    -------

    flank_dict : dict, dictionary of flanks and methylation statistics
    """

    seq_start = int(22 / 2 - len(motif) / 2 - flank_size)
    seq_end = int(22 / 2 + len(motif) / 2 + flank_size)
    
    with open(infile, "r") as fh:
        data = fh.readlines()
        for line in data:
            header, sequence = line.split()
            header_splited = header.split(":")[0].split(";")
            mC, total = header_splited[0], header_splited[1]
            depth = int(total)
            if depth >= depth_limit:
                flank = sequence.upper()[seq_start:seq_end]
                if flank in flank_dict.keys():
                    meth_level = int(mC) / depth  # methylation level
                    flank_dict[flank][0] += 1  # increament count
                    flank_dict[flank][
                        1
                    ] += meth_level  # add methylation level to compute average at the end

    # compute average methylation
    for key, value in flank_dict.items():
        if value[0] > 0:
            flank_dict[key][1] = value[1] / value[0]

    return flank_dict

def _compute_flanks_distribution(
    infile: str, flank_size: int, flank_dict: OrderedDict, motif: str = "CG"
):
    """Computes the number of observations of each flank in a file (genome), does not analyse methylation.
    !!! In the current implementation uses 22 nt sequences as inputs!!!
    
    Parameters
    ----------

    infile : str, input file with sequences and methylation data (generated by bedtools getfasta)
        examplary line: 1;13;CG;CG::chr1:3010402-3010424(+) ctggactgggcgaagtgggtgt
    
    flank_size : int, a number of nucleotides flanking a central motif to analyse (max 3)
    flank_dict : dict, a dictionary of flanks to store statistics, generated by _make_flanks_dict
    
    motif : str, a central motif.
        E.g. CG, CA, etc., default = "CG"
    
    Returns
    -------

    flank_dict : dict, a dictionary of flanks and their occurrences
    """

    seq_start = int(22 / 2 - len(motif) / 2 - flank_size)
    seq_end = int(22 / 2 + len(motif) / 2 + flank_size)

    with open(infile, "r") as fh:
        data = fh.readlines()
        for line in data:
            _, sequence = line.split()
            flank = sequence.upper()[seq_start:seq_end]
            if flank in flank_dict.keys():
                flank_dict[flank][0] += 1
            line = fh.readline()

    return flank_dict

def _compute_flanks_methylation_level(
    infile: str, flank_size: int, flank_dict: OrderedDict, motif: str = "CG"
):
    """Computes methylation of flanks
    This version is created to analyse files, which has no sequencing depth info, but only methylation level.
    !!! In the current implementation uses 22 nt sequences as inputs!!!
    
    Parameters
    ----------
    
    infile : str, an input file with sequences and methylation levels
        an examplary line of such a file: NA;0.222;NA;NA::chr1:3010402-3010424(+) ctggactgggcgaagtgggtgt
        where 0.222 - is a methylation level
    
    flank_size : int, a number of nucleotides (flanking CG) to analyse (max 3)
    flank_dict : dict, a disctionary of flanks to store statistics,
        generated by _make_flanks_dict
    
    motif : str, a central motif.
        E.g. CG, CA, etc., default = "CG"
    
    Returns
    -------

    flank_dict : dict, a dictionary of flanks and methylation statistics
    """

    seq_start = int(22 / 2 - len(motif) / 2 - flank_size)
    seq_end = int(22 / 2 + len(motif) / 2 + flank_size)
    
    with open(infile, "r") as fh:
        data = fh.readlines()
        for line in data:
            header, sequence = line.split()
            header_splited = header.split(":")[0].split(";")
            meth_level = float(header_splited[1])
            flank = sequence.upper()[seq_start:seq_end]
            if flank in flank_dict.keys():
                flank_dict[flank][0] += 1
                flank_dict[flank][
                    1
                ] += meth_level  # add methylation level to compute average at the end

    # compute average methylation
    for key, value in flank_dict.items():
        if value[0] > 0:
            flank_dict[key][1] = value[1] / value[0]

    return flank_dict

def _save_data(data: OrderedDict[str, list], outfile: str):
    """Saves statistics of flanks methylation into a file
    
    Parameters
    ----------
    data : dict, a dictionary, where key=flank, value=list[counts,average methylation]
    outfile : str, file name to write data
    """

    with open(outfile, "a+") as sh:
        header_to_data = ";".join(["Site", "Occurrence", "Av. mC\n"])
        sh.write(header_to_data)
        for key, values in data.items():
            to_write = ";".join([key, str(values[0]), str(values[1])])
            sh.write(to_write)
            sh.write("\n")
        sh.write("\n")


if __name__ == "__main__":
    main()